# Introduction to the R Environment {#ch1}

---

## Session Overview{-}

In this first session, we will get familiar with the basics of using R. We will cover:

*  the use of R as a basic calculator
*  object types
*  data classes
*  data structures
*  how to read in data
*  how to write out data
*  how to write your own functions

## Getting Started: Install R and RStudio

First off, you will need to get R and RStudio^[While it is possible to run R on it's own, it rather clunky and you are strongly advised to use RStudio given its compactness, neat features, code tools (like syntax and parentheses highlighting). This workshop will assume you are using RStudio] onto your computer. Please see **Appendix A** for details on installing these programs on your operating system.

## The R Studio Interface

Once you open up R Studio for the first time, you will see three panes: the left hand side is the **console** where results from executed commands are printed, and the two panes on the right are for additional information to help you code more efficiently - don't worry too much about what these are at the moment. For now, focus your attention on the console.

### Write Some Simple Code

To start off, we will just use R as a calculator. Type these commands (not the lines with `##`, those are output^[The formatting used here includes `##` on output to denote code and output separately. You won't see the `##` show up in your console.]) one at a time and hit **CTRL + ENTER** to run it. The spaces don't matter at all, they are used here for clairity and for styling.^[To learn more about standard R code styling, check out Hadley Wickham's [great chapter](http://adv-r.had.co.nz/Style.html) about it.]

```{r Calculator}
3 + 3
12/4
```

Notice that when you run each line, it prints the command and the output to the console. 

R is an **object oriented language**, which means that you fill objects with data do things with them. Make an object called `x` that stores the result of the calculation `3 + 3` (type this and run using **CTRL + ENTER**):

```{r}
x = 3 + 3
```

Notice that running this line did not return a value as before. This is because in that line you are **assigning** a value to the object `x`. You can view the contents of `x` by typing its name alone and running just that:

```{r}
x
```

When used this way, the `=` sign denotes assignment of the value on the right-hand side to an object with the name on the left-hand side. The `<-` serves this same purpose, but in this context the two are interchangable:

```{r}
y <- 2 + 5
```

You can highlight smaller sections of a line to run as well. For example after creating `y` above, press the **up arrow**, highlight just the `y`, and press **CTRL + ENTER**. From this point forward, the verb "run" means execute some code using **CTRL + ENTER**.

You can use your objects together to make a new object:

```{r}
z = y - x
```

## Saving Your Code: Scripts

If we closed R at this moment, our work would be lost. Running code in the console like we have just done **does not save a record of your work**. To save R code, we use what is called a **script**, which is a plain-text file with the extension `.R`. To create a new script file, go to _File > New File > R Script_, or use the keyboard shortcut **CTRL + SHIFT + N**. A new pane will open called the **source** pane - this is where you will edit your code and save your progress. R Scripts are a key feature of reproducible research with R, given that if they are well-written they can present a complete roadmap of your statistical analysis and workflow.

## The Working Directory

You will want to save your hard work. A key part of doing saving your work is thinking about **where** you save it. In R, a key concept is the **working directory**. This is the location (i.e., folder) on your computer where your current R session will "talk to" by default. The working directory is where R will read files from and write files to by default, and is where all of your data should be stored for your analysis in R. Because you'll likely be visiting it often, it should probably be somewhere that is easy to remember and not too deeply buried in your computer's file system. 

Save your script somewhere like `C:/Users/YOU/Documents/R-Workshop/Chapter1` on your computer. To set the working directory to this location, you have three options:

1.  **Go to Session > Set Working Directory > Source File Location**. This will set the working directory to the location of the file that is currently open in your source pane.

2. **Go to Session > Set Working Directory > Choose Directory**. This will open an interactive file selection window to allow you to navigate to the desired directory.

3. **Use code**. In the console, you can type `setwd("C:/Users/YOU/Documents/R-Workshop/Chapter1")`. If at any point you want to know where your current working directory is set to, you can either look at the top of the console pane, which shows the full path or by running `getwd()` in the console.

**The main benefits of using a working directory are**:

*  files are read from and written to a consistent and predictable place everytime
*  everything for your analysis is organized into one place
*  you don't have to continously type file paths to your work. If `file.txt` is a file in your current working directory, you can reference it your R session using `"file.txt"` rather than with `"C:/Users/YOU/Documents/R-Workshop/Chapter1/file.txt"` each time.

## R Object Types

R has a variety of object types that you will need to become familiar with.

### Functions

Much of your work in R will involve functions. A function is called using the syntax:

```{r, eval = F}
fun(arg1 = value1, arg2 = value2)
```

Here, `fun` is the **function name** and `arg1` and `arg2` are called **arguments**. Functions take input in the form of the arguments, do some task with them, then return some output. The parentheses are a sure sign that `fun` is a function.

We have passed the function two arguments by name: all functions have arguments, all arguments have names, and there is always a default order to the arguments. If you memorize the order of functions you use frequently, you don't have to specify the argument name:

```{r, eval = F}
fun(value1, value2)
```

would give the same result as the command above.

Here's a real example:

```{r}
print(x = z)
```

The function is `print`, the argument is `x`, and the value we have supplied the argument is the object `z`. The task that `print` does with our object is to print its value to the console.

R has lots of built-in information to help you learn how to use a function. Let's look at the help file for the mean function. Run `?mean` in the console: a window on the right-hand side of the R Studio interface should open. The help file tells you what goes into a function and what comes out. For more complex functions it also tells you what all of the options (i.e., arguments) can do. Help files can be a bit intimidating to interpret at first, but they are all organized the same and once you learn their layout you will know where to go to find the information you're looking for.

### Vectors

Vectors are one of the most common data structures. A vector is a set of numbers going in only one dimension. Each position in a vector is termed an **element**, and the number of elements is termed the **length** of the vector. Here are some ways to make some vectors with different elements, all of length five with patterns:

```{r}
# this is a comment. R will ignore all text on a line after a #
# the ; means run everything after it on a new line

# count up by 1
month = 2:6; month

# count up by 2
day = seq(from = 1, to = 9, by = 2); day

# repeat the same number (repeat 2018 5 times)
year = rep(2018, 5); year

```

The `[1]` that shows up is a element position, more on this later. If you wish to know how many elements are in a vector, use `length`:

```{r}
length(year)
```

You can also create a vector "by-hand" using the `c` function^[The `c` stands for **concatenate**, which basically means combine many smaller objects into one larger object]:

```{r}
# a numeric vector
number = c(4, 7, 8, 10, 15); number

# a character vector
pond = c("F11", "S28", "S30", "S8", 'S11'); pond
```

Note the difference between the numeric and character vectors. The the terms "numeric" and "character"" represent **data classes**, which specify the type of data the vector is holding:

*  A **numeric vector** stores numbers. You can do math with numeric vectors
*  A **character vector** stores what are essentially letters. You can't do math with letters. A character vector is easy to spot because the elements will be wrapped with quotes^[`" "` or `' '` both work as long as you use the same on the front and end of the element]. 

A vector can only hold one data class at a time:

```{r}
v = c(1,2,3,"a"); v
```

Notice how all the elements now have quotes around them. The numbers have been **coerced** to characters^[The coersion works this way because numbers can be expressed as characters, but a letter cannot be unambiguously be expressed as a number.]. If we attempted to calculate the sum of our vector:

```{r, error=T}
sum(v)
```

we would find that it is impossible in its current form.

### Matrices

Matrices act just like vectors, but they are in two dimensions, i.e., they have both rows and columns. One easy way to make a matrix is by combining vectors you have already made:

```{r}
# combine vectors by column (each vector will become a column)
m1 = cbind(month, day, year, number); m1

# combine vectors by row (each vector will become a row)
m2 = rbind(month, day, year, number); m2
```

Just like vectors, matrices can hold only one data class (note the coersion of numbers to characters):

```{r}
cbind(m1, pond)
```

### Data Frames

Most of the data sets we work will will require storing different data classes in different columns, which would rule out the use of a matrix. This is where **data frames** come in:

```{r}
df1 = data.frame(month, day, year, number, pond); df1
```

Notice the lack of quotation marks which indicates that all variables (i.e., columns) are stored as their original data class.

It is important to know what kind of object type you are using, since R treats them differently. For example, some functions can only use a certain object type. The same holds true for data classes (numeric vs. character vs. factor).You can quickly determine what kind of object you are dealing with by using the `class` function.  Simply run `class(object.name)`:

```{r}
class(day); class(pond); class(m1); class(df1)
```

## Vector Math

R does vectorized calculations. This means that if supplied with two numeric vectors of equal length and a mathematical operator, R will perform the calculation on each pair of elements: For example, if we wanted to add the two vectors vector `day` and `month`, then we would just run:

```{r}
dm = day + month; dm
```

We could do the same calculation (e.g., divide by 2) to each element as follows:

```{r}
dm/2
```

## Data Queries/Subsets/Retrievals

This perhaps the most important and versatile skills to know in R. So we have an object with data in it and we want to use it for analysis. But we don't want the whole dataset. We want to use just a few rows or just a few columns. This section is devoted to ways you can extract certain parts of a data object (the terms **query** and **subset** are often used interchangeably to describe this task). There are two main methods:

1.  **By Index**. This method allows you to pull out specific columns/rows by their location in an object. However, you must know exactly where in the object the desired data are. An **index** is a location of a element in a data object, like the element position or the position of a specific row or column. To subset by index, you specify the object, then what rows, then what columns. The syntax for subsetting a vector by index is `vector[element]` and for a matrix it is `matrix[row,column]`. Here are some examples

```{r}
# subset the third element of day
day[3]

# subset the element in the first row, third column from m1
m1[1,3]

# suset the entire first column of df1
df1[,1]
```

Note this last line: the `[,1]` says "keep all the rows, but take only the first column".

Here is another example: 
```{r}
# subset the 1st, 2nd, and 4th, rows of every column from m1
m1[c(1, 2, 4), ]
```

**2. By name** -- This method allows you to pull out a specific column of data based on what the column name is. Of course, the column must have a name first. The name method uses the `$` operator:

```{r, eval = F}
df1$num
```

You can combine these two methods:

```{r, eval = F}
df1$num[3]

# or
df1[, "years"]
```

The by name (`$`) method is useful because it can be used to add columns to a data frame:

```{r, eval = F}
df1$num3 = seq(1, 10, 2)
df1
```

Both are very useful, and we will be making frequent use of these methods for the rest of the workshop. The `$` operator only works on data frames, not matrices. I'll mention briefly that there is another way to query data: logically.  We will cover this in the next section. Now go and try your hand at applying these skills in **EXERCISE 1**.

# Bringing in Your Data

It is rare that we will enter our data by hand as we did in Exercise 1. Often, we have a dataset that we wish to analyze or manipulate. R has several ways to bring in data and in this workshop, we will be using the most common and flexible approach: reading in .csv files. CSV files are data files that separate columns with commas. If your data are in an Excel spreadsheet, save your Excel file as a CSV file (File > Save As > Save as Type> CSV (Comma Delimited)). Excel will give lots of dialog boxes asking if you are sure you want to save it as a CSV (you do) and if you wish to save it. A few things to note: 

*  No cells can contain the "#VALUE!" or "NUM" result that often happens when the result of an Excel function is invalid. If one of these is found in a column, R will treat that _entire_ column as a factor (because it contains characters), which causes problems when you do not want that column to be a factor (remember a factor is a grouping variable, like treatment, location, or species).

*  If a cell in the first row with text contains a space between two words, R will insert a `"."` between the words.

*  R can deal with missing values by turning them into `NA`. However, everywhere you want R to have an `NA`, those cells must contain the same information in the CSV file. These can be completely empty cells, or you could put a `"."` into every cell that you want R to treat as an `NA`.  If you use "`.`" to signify `NA` in your CSV file, include `na.strings = "."` as an argument to the `read.csv()` function described below.  Of course, you can also simply type "NA" in the CSV file wherever NA's occur.

*  If your data have column names (i.e., characters) in the first row, R will bring those in as column names by default.  

*  R brings in CSV files in as data frames by default.

The website I'm using won't let me upload CSV files, so we will have to convert Excel workbooks (.xlsx) to CSV files. Once that is done, to bring (read) in a CSV file we use the function `read.csv()`. `read.csv()` has several arguments (look at the help file for details), but only one is really necessary: the file name (or location). Let's convert and read in the provided dataset "streams.xlsx" (there are no problems with this dataset, so don't worry):

```{r, eval = F}
dat = read.csv("streams.csv")
```

If the data set is in your working directory, all you need to provide is the file name (remember case, quotes, and .csv at the end!). If the file is _not_ in your working directory, you must type (or copy/paste) the _full_ file path.  Note that R requires the use of `/` and not `\` in file paths.  For example: 

```{r, eval = F}
dat = read.csv("C:/Users/Ben/Desktop/Auburn R Workshops/Session 1/Session 1 MarkDown/Session-1-data.csv")
```

If you did not get any errors, then the data are in the object you named and that object is a data frame. If you get errors (e.g., `...No such file or directory`) then make sure you have spelled everything correctly, used the right case and symbols, and have included a ".csv" at the end of the file name. Don't worry, this is probably one of the most common errors I get in R.

There is a neat trick to simplify this. Running `read.csv(file.choose())` pulls up a window that allows you to interactively choose the file you want. (running `file.choose` returns the file path of the file you select, so it is really just the same as typing in the file path, but easier). I don't use this for complex analyses, because when I come back to that script later, I want to make sure I'm using the right data file. Typing the file name instead of using `file.choose`helps me with this.

Let's look at the data. We could just run the object, but it will show the whole thing, which may be undesirable if the dataset is large. To view the first six rows, run `head(dat)` or the last six rows with `tail(dat)`.

Okay, now we will use some basic functions to explore our data before any analysis. The `summary` function is very useful, and it can be used on a large variety of different objects. 

```{r, eval = F}
summary(dat)
```

We can now see the spread of our numeric data and see the different levels of our factor (`state`) as well as how many data points belong to each category. Note that we have one `NA` in our `flow` variable.

To count the number of elements in a variable (or any vector), we use the `length` function:

```{r, eval = F}
length(dat$stream_width)
```

Note that R counts missing values as elements as well:

```{r, eval = F}
length(dat$flow)
```

To get the dimensions of an object with more than one dimension (i.e., a data frame, matrix, or array) we can use the `dim` function. This returns a vector of length 2: the first number is the number of rows and the second is the number of columns. If you only want one of these, use the `nrow` or `ncol` functions (but remember, only for objects with more than one dimension; vectors don't have rows or columns!).

```{r, eval = F}
dim(dat)
```

Let's calculate the mean of all of our flow data:

```{r, eval = F}
mean(dat$flow)
```

It returned an `NA` because there is an `NA` in this variable. There is a way to tell R to ignore this `NA`. Include the argument `na.rm = TRUE` in the `mean` function (separate arguments are always separated by commas). This is a **logical** argument, meaning that it asks a question. Do you want to remove `NAs` before calculating the mean? `TRUE` means yes and `FALSE` means no. These can be abbreviated as `T` or `F`.  Lots of R's functions have the `na.rm` argument (e.g. `mean`, `sd`, `var`, `min`, `max`, `sum`, etc.).  

```{r, eval = F}
mean(dat$flow, na.rm = T)
```

What if we want to do something to more than one variable at a time? The best way to do this (as with lots of things in R, there are many) is by using the `apply` function. This applies the same function to a subset of data.  Note that we must specify the `na.rm` argument to the `var` function within the `apply` function:

```{r, eval = F}
apply(dat[,2:3], 2, FUN = var, na.rm = T)
```

The first argument is the data we want to apply the function to. The second argument (the number `2`) specifies that we want to apply the function to columns, `1` would tell R to apply it to rows. The `FUN` argument specifies what function we wish to apply; here we are calculating the variance. There is a whole family of `apply` functions, the base `apply` is the most basic but a more sophisticated one is `tapply`, which applies a function based on some grouping variable. Let's calculate the mean stream width for every state:

```{r, eval = F}
tapply(dat$stream_width, dat$state, mean)
```

The first argument is the data you want to apply the `mean` function to, the second is the grouping variable, and the third is what function you wish to apply.

# Logic, `if`, `else`, and `ifelse`

R is a very logical language, both in a literal a figurative sense. When we say "logical", as alluded to before, we are really talking about a question. You will also see these referred to as **conditionals**. Which values in a vector meet some condition (greater than some number, are equal to some number, have the same characters, etc.)? Let's start with some very basic R logic (note that reassigning a value to `num` will write over what it was before, be careful with this):

```{r}
num = 5   # assign a value to the object num
num < 5   # ask if it is less than 5
num <= 5  # ask if it is less than or equal to 5
num == 5  # ask if it is exactly equal to 5
```

Each of these lines (after the first which assigns a value to value) asks a question: does `num` meet the specified condition? It returns `TRUE` if it does, and `FALSE` if it doesn't. Note that the logical equals is specified by using `==`.

We can tell R to do something if the result of our logical question is `TRUE`. This is a typical if-then statement. 

```{r}
if (num == 5) print("num is equal to 5")
```

This says "if `num` equals 5, then print the phrase 'num is equal to 5' to the console". If the logical returns a `FALSE`, then this command does nothing:

```{r}
if (num != 5) print("num is equal to 5")
```

The `!` is the logical _not_. It asks the question "is `num` not equal to 5?". We can tell R to do multiple things if the logical is `TRUE` by using curly braces:

```{r}
if (num == 5) {
  print("num is equal to 5")
  print("num is supposed to be 6")
}
```
 
But what if we want R to do something if the logical is `FALSE`? Then we use the `else` command:

```{r}
if (num > 5) print("num is greater than 5") else print("num is not greater than 5")
```

Or on two lines:

```{r}
if (num > 5) {
  print("num is greater than 5")
} else print("num is not greater than 5")
```

The `if` function is very useful, but it can only ask one question at a time. If you supply it with a vector of length greater than 1, it will give a warning that only the first value is used. (Warnings are different than errors in that something still happens, but it tells you that it might not be what you wanted, whereas an error stops R altogether.)  To ask multiple questions at once, we must use `ifelse`. This function is similar, but it combines the syntax into one function:

```{r}
nums = c(-5:-1, 1:5)
ifelse(nums > 0, "positive", "negative")
```

The syntax is `ifelse(logical condition, do if TRUE, do if FALSE)`. Let's use `ifelse` to create a new variable in `dat` that tells us if each stream is big or small depending on some cut-off we choose:

```{r, eval = F}
dat$size = ifelse(dat$stream_width > 50, "big", "small")
```

This says "make a new variable in the data frame `dat` called `size` and assign each row a 'big' if `stream_width` is greater than 50 or 'small' if less than 50". 

One neat thing about `ifelse` is that you can nest multiple statements inside another (this is true of ALL R functions, by the way). What if we wanted three categories: small, medium, and large?

```{r, eval = F}
dat$size_fine = ifelse(dat$stream_width <= 40, "small",
                     ifelse(dat$stream_width > 40 & dat$stream_width <= 70, "medium", "big"))
```

If the value is `TRUE`, then it will give it a "small". If not, it will start another `ifelse` to ask if the value is greater than 50 _and_ less than or equal to 70. If so, it will give it a "medium", if not it will get a "big". This is confusing at first, I know. Not all nesting or embedding of functions are this complex, but this is a neat example.  Without `ifelse`, you would have to use as many `if` statements as there are data points, and do you really want to do that? I'll note that in addition to the logical _and_ (`&`) there is a logical _or_, denoted by the bar symbol (`|`).

# Logical Subsetting

This is my favorite way of subsetting (or querying or retrieving data, however you want to say it) an object. It pulls out all of the elements of an object for which the test is `TRUE`. For example:

```{r, eval = F}
dat$flow[dat$stream_width > 60]
```

Gives all of the flow values for which stream width is greater than 60. Or to see all of the data from Alabama:

```{r, eval = F}
dat[dat$state == "Alabama",]
```

The `subset()` function does this same thing:

```{r, eval = F}
subset(dat, state == "Alabama")
```

The syntax is `subset(object, condition)`.  You can specify multiple conditions:

```{r, eval = F}
big.TN.FL.rivers = subset(dat, dat$size_fine == "big" & 
              (dat$state == "Tennessee" | dat$state == "Florida"))
big.TN.FL.rivers
```

This gives all rivers that are big and are in Tennessee or Florida.  Note that to do big and either in Tennessee or Florida, the states need to be in parentheses because this last part is its own question.

# Writing Output Files

Okay so now that we have made some new variables in our data frame, we want to save this work in the form of a new CSV file. To do this, we can use the `write.csv` function:

```{r, eval = F}
write.csv(dat, "updated_output.csv", row.names = F)
```

The first argument is the data frame (or matrix) to write, the second is what you want to call it, and `row.names = F` tells R to not include the row names (because here they are just numbers in this case). R puts the file in your working directory by default. To put it somewhere else, type in the path with the new file name at the end. 

# Basic User-Defined Functions

Sometimes we want R to carry out a specific task, but there is no function built in to do it. In this case, we can write our own functions. This is one of the coolest parts of R, and I will only introduce it here. We will be going into more detail on this topic in later sessions.

First, we must think of a name for our function. Then, we specify the function using the `function` function. Then, in parentheses, we specify any arguments that we want to use within the function to carry out the specific task. Open and closed curly braces specify the start and end of our function. Let's write a general function to take any number to any power:

```{r}
power = function(x, y){
  x^y
}

```

Now let's test our function:

```{r}
power(5, 3)
```

Remember, we can embed functions:
```{r}
power(power(5,2),2)
```

This is the equivalent of (5^2^)^2^.

# That's All! (for now)

So there are the basics of what you need to know to get started in R! I hope you found this useful. I know there is a lot of information here but once you get the hang of it, this stuff will seem trivial. When I first learned this introductory material, I thought I would never be able to remember all the rules and syntax but the more you implement these skills, the less you need to look at reference material like this workbook and help files and the more you see how truly versatile this amazing program is. Keep in mind that there are _tons_ of resources out there to help you learn R (see the website). I can't tell you how many times typing out a word-for-word question into Google helped me get past a dead end.

Now go try out **EXERCISE 2** (this one's a bit trickier!).  
