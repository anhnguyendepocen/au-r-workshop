[
["ch1.html", "Chapter 1 Introduction to the R Environment Session Overview 1.1 Getting Started: Install R and RStudio 1.2 The R Studio Interface 1.3 Saving Your Code: Scripts 1.4 The Working Directory 1.5 R Object Types 1.6 Vector Math 1.7 Data Queries/Subsets/Retrievals", " Chapter 1 Introduction to the R Environment Session Overview In this first session, we will get familiar with the basics of using R. We will cover: the use of R as a basic calculator object types data classes data structures how to read in data how to write out data how to write your own functions 1.1 Getting Started: Install R and RStudio First off, you will need to get R and RStudio1 onto your computer. Please see Appendix A for details on installing these programs on your operating system. 1.2 The R Studio Interface Once you open up R Studio for the first time, you will see three panes: the left hand side is the console where results from executed commands are printed, and the two panes on the right are for additional information to help you code more efficiently - don’t worry too much about what these are at the moment. For now, focus your attention on the console. 1.2.1 Write Some Simple Code To start off, we will just use R as a calculator. Type these commands (not the lines with ##, those are output2) one at a time and hit CTRL + ENTER to run it. The spaces don’t matter at all, they are used here for clairity and for styling.3 3 + 3 ## [1] 6 12/4 ## [1] 3 Notice that when you run each line, it prints the command and the output to the console. R is an object oriented language, which means that you fill objects with data do things with them. Make an object called x that stores the result of the calculation 3 + 3 (type this and run using CTRL + ENTER): x = 3 + 3 Notice that running this line did not return a value as before. This is because in that line you are assigning a value to the object x. You can view the contents of x by typing its name alone and running just that: x ## [1] 6 When used this way, the = sign denotes assignment of the value on the right-hand side to an object with the name on the left-hand side. The &lt;- serves this same purpose, but in this context the two are interchangable: y &lt;- 2 + 5 You can highlight smaller sections of a line to run as well. For example after creating y above, press the up arrow, highlight just the y, and press CTRL + ENTER. From this point forward, the verb “run” means execute some code using CTRL + ENTER. You can use your objects together to make a new object: z = y - x 1.3 Saving Your Code: Scripts If we closed R at this moment, our work would be lost. Running code in the console like we have just done does not save a record of your work. To save R code, we use what is called a script, which is a plain-text file with the extension .R. To create a new script file, go to File &gt; New File &gt; R Script, or use the keyboard shortcut CTRL + SHIFT + N. A new pane will open called the source pane - this is where you will edit your code and save your progress. R Scripts are a key feature of reproducible research with R, given that if they are well-written they can present a complete roadmap of your statistical analysis and workflow. 1.4 The Working Directory You will want to save your hard work. A key part of doing saving your work is thinking about where you save it. In R, a key concept is the working directory. This is the location (i.e., folder) on your computer where your current R session will “talk to” by default. The working directory is where R will read files from and write files to by default, and is where all of your data should be stored for your analysis in R. Because you’ll likely be visiting it often, it should probably be somewhere that is easy to remember and not too deeply buried in your computer’s file system. Save your script somewhere like C:/Users/YOU/Documents/R-Workshop/Chapter1 on your computer. To set the working directory to this location, you have three options: Go to Session &gt; Set Working Directory &gt; Source File Location. This will set the working directory to the location of the file that is currently open in your source pane. Go to Session &gt; Set Working Directory &gt; Choose Directory. This will open an interactive file selection window to allow you to navigate to the desired directory. Use code. In the console, you can type setwd(&quot;C:/Users/YOU/Documents/R-Workshop/Chapter1&quot;). If at any point you want to know where your current working directory is set to, you can either look at the top of the console pane, which shows the full path or by running getwd() in the console. The main benefits of using a working directory are: files are read from and written to a consistent and predictable place everytime everything for your analysis is organized into one place you don’t have to continously type file paths to your work. If file.txt is a file in your current working directory, you can reference it your R session using &quot;file.txt&quot; rather than with &quot;C:/Users/YOU/Documents/R-Workshop/Chapter1/file.txt&quot; each time. 1.5 R Object Types R has a variety of object types that you will need to become familiar with. 1.5.1 Functions Much of your work in R will involve functions. A function is called using the syntax: fun(arg1 = value1, arg2 = value2) Here, fun is the function name and arg1 and arg2 are called arguments. Functions take input in the form of the arguments, do some task with them, then return some output. The parentheses are a sure sign that fun is a function. We have passed the function two arguments by name: all functions are arguments, all arguments have names, and there is always a default order to the arguments. If you memorize the order of functions you use frequently, you don’t have to specify the argument name: fun(value1, value2) would give the same result as the command above. Here’s a real example: print(x = z) ## [1] 1 The function is print, the argument is x, and the value we have supplied the argument is the object z. The task that print does with our object is to print its value to the console. R has lots of built-in information to help you learn how to use a function. Let’s look at the help file for the mean function. Run ?mean in the console: a window on the right-hand side of the R Studio interface should open. The help file tells you what goes into a function and what comes out. For more complex functions it also tells you what all of the options (i.e., arguments) can do. Help files can be a bit intimidating to interpret at first, but they are all organized the same and once you learn their layout you will know where to go to find the information you’re looking for. 1.5.2 Vectors Vectors are one of the most common data structures. A vector is a set of numbers going in only one dimension. Each position in a vector is termed an element, and the number of elements is termed the length of the vector. Here are some ways to make some vectors with different elements, all of length five with patterns: # this is a comment. R will ignore all text on a line after a # # the ; means run everything after it on a new line # count up by 1 month = 2:6; month ## [1] 2 3 4 5 6 # count up by 2 day = seq(from = 1, to = 9, by = 2); day ## [1] 1 3 5 7 9 # repeat the same number (repeat 2018 5 times) year = rep(2018, 5); year ## [1] 2018 2018 2018 2018 2018 If you wish to know how many elements are in a vector, use length: length(year) ## [1] 5 You can also create a vector “by-hand” using the c function4: # a numeric vector number = c(4, 7, 8, 10, 15); number ## [1] 4 7 8 10 15 # a character vector pond = c(&quot;F11&quot;, &quot;S28&quot;, &quot;S30&quot;, &quot;S8&quot;, &#39;S11&#39;); pond ## [1] &quot;F11&quot; &quot;S28&quot; &quot;S30&quot; &quot;S8&quot; &quot;S11&quot; Note the difference between the numeric and character vectors. The the terms “numeric” and “character”&quot; represent data classes, which specify the type of data the vector is holding: A numeric vector stores numbers. You can do math with numeric vectors A character vector stores what are essentially letters. You can’t do math with letters. A character vector is easy to spot because the elements will be wrapped with quotes5. A vector can only hold one data class at a time: v = c(1,2,3,&quot;a&quot;); v ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;a&quot; Notice how all the elements now have quotes around them. The numbers have been coerced to characters6. If we attempted to calculate the sum of our vector: sum(v) ## Error in sum(v): invalid &#39;type&#39; (character) of argument we would find that it is impossible in its current form. 1.5.3 Matrices Matrices act just like vectors, but they are in two dimensions, i.e., they have both rows and columns. One easy way to make a matrix is by combining vectors you have already made: # combine vectors by column (each vector will become a column) m1 = cbind(month, day, year, number); m1 ## month day year number ## [1,] 2 1 2018 4 ## [2,] 3 3 2018 7 ## [3,] 4 5 2018 8 ## [4,] 5 7 2018 10 ## [5,] 6 9 2018 15 # combine vectors by row (each vector will become a row) m2 = rbind(month, day, year, number); m2 ## [,1] [,2] [,3] [,4] [,5] ## month 2 3 4 5 6 ## day 1 3 5 7 9 ## year 2018 2018 2018 2018 2018 ## number 4 7 8 10 15 Just like vectors, matrices can hold only one data class (note the coersion of numbers to characters): cbind(m1, pond) ## month day year number pond ## [1,] &quot;2&quot; &quot;1&quot; &quot;2018&quot; &quot;4&quot; &quot;F11&quot; ## [2,] &quot;3&quot; &quot;3&quot; &quot;2018&quot; &quot;7&quot; &quot;S28&quot; ## [3,] &quot;4&quot; &quot;5&quot; &quot;2018&quot; &quot;8&quot; &quot;S30&quot; ## [4,] &quot;5&quot; &quot;7&quot; &quot;2018&quot; &quot;10&quot; &quot;S8&quot; ## [5,] &quot;6&quot; &quot;9&quot; &quot;2018&quot; &quot;15&quot; &quot;S11&quot; 1.5.4 Data Frames Most of the data sets we work will will require storing different data classes in different columns, which would rule out the use of a matrix. This is where data frames come in: df1 = data.frame(month, day, year, number, pond); df1 ## month day year number pond ## 1 2 1 2018 4 F11 ## 2 3 3 2018 7 S28 ## 3 4 5 2018 8 S30 ## 4 5 7 2018 10 S8 ## 5 6 9 2018 15 S11 Notice the lack of quotation marks which indicates that all variables (i.e., columns) are stored as their original data class. It is important to know what kind of object type you are using, since R treats them differently. For example, some functions can only use a certain object type. The same holds true for data classes (numeric vs. character vs. factor).You can quickly determine what kind of object you are dealing with by using the class function. Simply run class(object.name): class(day); class(pond); class(m1); class(df1) ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; ## [1] &quot;matrix&quot; ## [1] &quot;data.frame&quot; 1.6 Vector Math R does vectorized calculations. This means that if supplied with two numeric vectors of equal length and a mathematical operator, R will perform the calculation on each pair of elements: For example, if we wanted to add the two vectors vector day and month, then we would just run: dm = day + month; dm ## [1] 3 6 9 12 15 We could do the same calculation (e.g., divide by 2) to each element as follows: dm/2 ## [1] 1.5 3.0 4.5 6.0 7.5 1.7 Data Queries/Subsets/Retrievals This is one of the most important and versatile skills to know in R. So we have an object with data in it and we want to use it for analysis. But we don’t want the whole dataset, we just want one column. How do we pull out that one column? Another term for pulling out only data we want is query. Well it turns out there are two main ways to query data. 1. Indexing. This method allows you to pull out specific columns/rows by their location in an object. However, you must know exactly where in the object the desired data are. To index, you specify the object, then what rows, then what columns. The syntax is: object[row, column]. For example, let’s pull out the first row of the data frame df1 using indexing: df1[1,] This works on matrices as well. Here are some examples: m1[1, 2] # pulls out the element in the first row, second column from m1 m1[, 2] # pulls out the whole second column (every row) from m1 m2[, 2:4] # pulls out columns 2, 3, and 4 from m2 m1[c(1, 2, 4), ] # pulls out the 1st, 2nd, and 4th, rows, with every column from m1 Vectors are done the same way, except you only provide one number because there is only one dimension. For example: num[3] pulls out the 3rd element of the vector num. 2. By name – This method allows you to pull out a specific column of data based on what the column name is. Of course, the column must have a name first. The name method uses the $ operator: df1$num You can combine these two methods: df1$num[3] # or df1[, &quot;years&quot;] The by name ($) method is useful because it can be used to add columns to a data frame: df1$num3 = seq(1, 10, 2) df1 Both are very useful, and we will be making frequent use of these methods for the rest of the workshop. The $ operator only works on data frames, not matrices. I’ll mention briefly that there is another way to query data: logically. We will cover this in the next section. Now go and try your hand at applying these skills in EXERCISE 1. While it is possible to run R on it’s own, it rather clunky and you are strongly advised to use RStudio given its compactness, neat features, code tools (like syntax and parentheses highlighting). This workshop will assume you are using RStudio↩ The formatting used here includes ## on output to denote code and output separately. You won’t see the ## show up in your console.↩ To learn more about standard R code styling, check out Hadley Wickham’s great chapter about it.↩ The c stands for concatenate, which basically means combine many smaller objects into one larger object↩ &quot; &quot; or ' ' both work as long as you use the same on the front and end of the element↩ The coersion works this way because numbers can be expressed as characters, but a letter cannot be unambiguously be expressed as a number.↩ "],
["bringing-in-your-data.html", "Chapter 2 Bringing in Your Data", " Chapter 2 Bringing in Your Data It is rare that we will enter our data by hand as we did in Exercise 1. Often, we have a dataset that we wish to analyze or manipulate. R has several ways to bring in data and in this workshop, we will be using the most common and flexible approach: reading in .csv files. CSV files are data files that separate columns with commas. If your data are in an Excel spreadsheet, save your Excel file as a CSV file (File &gt; Save As &gt; Save as Type&gt; CSV (Comma Delimited)). Excel will give lots of dialog boxes asking if you are sure you want to save it as a CSV (you do) and if you wish to save it. A few things to note: No cells can contain the “#VALUE!” or “NUM” result that often happens when the result of an Excel function is invalid. If one of these is found in a column, R will treat that entire column as a factor (because it contains characters), which causes problems when you do not want that column to be a factor (remember a factor is a grouping variable, like treatment, location, or species). If a cell in the first row with text contains a space between two words, R will insert a &quot;.&quot; between the words. R can deal with missing values by turning them into NA. However, everywhere you want R to have an NA, those cells must contain the same information in the CSV file. These can be completely empty cells, or you could put a &quot;.&quot; into every cell that you want R to treat as an NA. If you use “.” to signify NA in your CSV file, include na.strings = &quot;.&quot; as an argument to the read.csv() function described below. Of course, you can also simply type “NA” in the CSV file wherever NA’s occur. If your data have column names (i.e., characters) in the first row, R will bring those in as column names by default. R brings in CSV files in as data frames by default. The website I’m using won’t let me upload CSV files, so we will have to convert Excel workbooks (.xlsx) to CSV files. Once that is done, to bring (read) in a CSV file we use the function read.csv(). read.csv() has several arguments (look at the help file for details), but only one is really necessary: the file name (or location). Let’s convert and read in the provided dataset “streams.xlsx” (there are no problems with this dataset, so don’t worry): dat = read.csv(&quot;streams.csv&quot;) If the data set is in your working directory, all you need to provide is the file name (remember case, quotes, and .csv at the end!). If the file is not in your working directory, you must type (or copy/paste) the full file path. Note that R requires the use of / and not \\ in file paths. For example: dat = read.csv(&quot;C:/Users/Ben/Desktop/Auburn R Workshops/Session 1/Session 1 MarkDown/Session-1-data.csv&quot;) If you did not get any errors, then the data are in the object you named and that object is a data frame. If you get errors (e.g., ...No such file or directory) then make sure you have spelled everything correctly, used the right case and symbols, and have included a “.csv” at the end of the file name. Don’t worry, this is probably one of the most common errors I get in R. There is a neat trick to simplify this. Running read.csv(file.choose()) pulls up a window that allows you to interactively choose the file you want. (running file.choose returns the file path of the file you select, so it is really just the same as typing in the file path, but easier). I don’t use this for complex analyses, because when I come back to that script later, I want to make sure I’m using the right data file. Typing the file name instead of using file.choosehelps me with this. Let’s look at the data. We could just run the object, but it will show the whole thing, which may be undesirable if the dataset is large. To view the first six rows, run head(dat) or the last six rows with tail(dat). Okay, now we will use some basic functions to explore our data before any analysis. The summary function is very useful, and it can be used on a large variety of different objects. summary(dat) We can now see the spread of our numeric data and see the different levels of our factor (state) as well as how many data points belong to each category. Note that we have one NA in our flow variable. To count the number of elements in a variable (or any vector), we use the length function: length(dat$stream_width) Note that R counts missing values as elements as well: length(dat$flow) To get the dimensions of an object with more than one dimension (i.e., a data frame, matrix, or array) we can use the dim function. This returns a vector of length 2: the first number is the number of rows and the second is the number of columns. If you only want one of these, use the nrow or ncol functions (but remember, only for objects with more than one dimension; vectors don’t have rows or columns!). dim(dat) Let’s calculate the mean of all of our flow data: mean(dat$flow) It returned an NA because there is an NA in this variable. There is a way to tell R to ignore this NA. Include the argument na.rm = TRUE in the mean function (separate arguments are always separated by commas). This is a logical argument, meaning that it asks a question. Do you want to remove NAs before calculating the mean? TRUE means yes and FALSE means no. These can be abbreviated as T or F. Lots of R’s functions have the na.rm argument (e.g. mean, sd, var, min, max, sum, etc.). mean(dat$flow, na.rm = T) What if we want to do something to more than one variable at a time? The best way to do this (as with lots of things in R, there are many) is by using the apply function. This applies the same function to a subset of data. Note that we must specify the na.rm argument to the var function within the apply function: apply(dat[,2:3], 2, FUN = var, na.rm = T) The first argument is the data we want to apply the function to. The second argument (the number 2) specifies that we want to apply the function to columns, 1 would tell R to apply it to rows. The FUN argument specifies what function we wish to apply; here we are calculating the variance. There is a whole family of apply functions, the base apply is the most basic but a more sophisticated one is tapply, which applies a function based on some grouping variable. Let’s calculate the mean stream width for every state: tapply(dat$stream_width, dat$state, mean) The first argument is the data you want to apply the mean function to, the second is the grouping variable, and the third is what function you wish to apply. "],
["logic-if-else-and-ifelse.html", "Chapter 3 Logic, if, else, and ifelse", " Chapter 3 Logic, if, else, and ifelse R is a very logical language, both in a literal a figurative sense. When we say “logical”, as alluded to before, we are really talking about a question. You will also see these referred to as conditionals. Which values in a vector meet some condition (greater than some number, are equal to some number, have the same characters, etc.)? Let’s start with some very basic R logic (note that reassigning a value to num will write over what it was before, be careful with this): num = 5 # assign a value to the object num num &lt; 5 # ask if it is less than 5 ## [1] FALSE num &lt;= 5 # ask if it is less than or equal to 5 ## [1] TRUE num == 5 # ask if it is exactly equal to 5 ## [1] TRUE Each of these lines (after the first which assigns a value to value) asks a question: does num meet the specified condition? It returns TRUE if it does, and FALSE if it doesn’t. Note that the logical equals is specified by using ==. We can tell R to do something if the result of our logical question is TRUE. This is a typical if-then statement. if (num == 5) print(&quot;num is equal to 5&quot;) ## [1] &quot;num is equal to 5&quot; This says “if num equals 5, then print the phrase ‘num is equal to 5’ to the console”. If the logical returns a FALSE, then this command does nothing: if (num != 5) print(&quot;num is equal to 5&quot;) The ! is the logical not. It asks the question “is num not equal to 5?”. We can tell R to do multiple things if the logical is TRUE by using curly braces: if (num == 5) { print(&quot;num is equal to 5&quot;) print(&quot;num is supposed to be 6&quot;) } ## [1] &quot;num is equal to 5&quot; ## [1] &quot;num is supposed to be 6&quot; But what if we want R to do something if the logical is FALSE? Then we use the else command: if (num &gt; 5) print(&quot;num is greater than 5&quot;) else print(&quot;num is not greater than 5&quot;) ## [1] &quot;num is not greater than 5&quot; Or on two lines: if (num &gt; 5) { print(&quot;num is greater than 5&quot;) } else print(&quot;num is not greater than 5&quot;) ## [1] &quot;num is not greater than 5&quot; The if function is very useful, but it can only ask one question at a time. If you supply it with a vector of length greater than 1, it will give a warning that only the first value is used. (Warnings are different than errors in that something still happens, but it tells you that it might not be what you wanted, whereas an error stops R altogether.) To ask multiple questions at once, we must use ifelse. This function is similar, but it combines the syntax into one function: nums = c(-5:-1, 1:5) ifelse(nums &gt; 0, &quot;positive&quot;, &quot;negative&quot;) ## [1] &quot;negative&quot; &quot;negative&quot; &quot;negative&quot; &quot;negative&quot; &quot;negative&quot; &quot;positive&quot; ## [7] &quot;positive&quot; &quot;positive&quot; &quot;positive&quot; &quot;positive&quot; The syntax is ifelse(logical condition, do if TRUE, do if FALSE). Let’s use ifelse to create a new variable in dat that tells us if each stream is big or small depending on some cut-off we choose: dat$size = ifelse(dat$stream_width &gt; 50, &quot;big&quot;, &quot;small&quot;) This says “make a new variable in the data frame dat called size and assign each row a ‘big’ if stream_width is greater than 50 or ‘small’ if less than 50”. One neat thing about ifelse is that you can nest multiple statements inside another (this is true of ALL R functions, by the way). What if we wanted three categories: small, medium, and large? dat$size_fine = ifelse(dat$stream_width &lt;= 40, &quot;small&quot;, ifelse(dat$stream_width &gt; 40 &amp; dat$stream_width &lt;= 70, &quot;medium&quot;, &quot;big&quot;)) If the value is TRUE, then it will give it a “small”. If not, it will start another ifelse to ask if the value is greater than 50 and less than or equal to 70. If so, it will give it a “medium”, if not it will get a “big”. This is confusing at first, I know. Not all nesting or embedding of functions are this complex, but this is a neat example. Without ifelse, you would have to use as many if statements as there are data points, and do you really want to do that? I’ll note that in addition to the logical and (&amp;) there is a logical or, denoted by the bar symbol (|). "],
["logical-subsetting.html", "Chapter 4 Logical Subsetting", " Chapter 4 Logical Subsetting This is my favorite way of subsetting (or querying or retrieving data, however you want to say it) an object. It pulls out all of the elements of an object for which the test is TRUE. For example: dat$flow[dat$stream_width &gt; 60] Gives all of the flow values for which stream width is greater than 60. Or to see all of the data from Alabama: dat[dat$state == &quot;Alabama&quot;,] The subset() function does this same thing: subset(dat, state == &quot;Alabama&quot;) The syntax is subset(object, condition). You can specify multiple conditions: big.TN.FL.rivers = subset(dat, dat$size_fine == &quot;big&quot; &amp; (dat$state == &quot;Tennessee&quot; | dat$state == &quot;Florida&quot;)) big.TN.FL.rivers This gives all rivers that are big and are in Tennessee or Florida. Note that to do big and either in Tennessee or Florida, the states need to be in parentheses because this last part is its own question. "],
["writing-output-files.html", "Chapter 5 Writing Output Files", " Chapter 5 Writing Output Files Okay so now that we have made some new variables in our data frame, we want to save this work in the form of a new CSV file. To do this, we can use the write.csv function: write.csv(dat, &quot;updated_output.csv&quot;, row.names = F) The first argument is the data frame (or matrix) to write, the second is what you want to call it, and row.names = F tells R to not include the row names (because here they are just numbers in this case). R puts the file in your working directory by default. To put it somewhere else, type in the path with the new file name at the end. "],
["basic-user-defined-functions.html", "Chapter 6 Basic User-Defined Functions", " Chapter 6 Basic User-Defined Functions Sometimes we want R to carry out a specific task, but there is no function built in to do it. In this case, we can write our own functions. This is one of the coolest parts of R, and I will only introduce it here. We will be going into more detail on this topic in later sessions. First, we must think of a name for our function. Then, we specify the function using the function function. Then, in parentheses, we specify any arguments that we want to use within the function to carry out the specific task. Open and closed curly braces specify the start and end of our function. Let’s write a general function to take any number to any power: power = function(x, y){ x^y } Now let’s test our function: power(5, 3) ## [1] 125 Remember, we can embed functions: power(power(5,2),2) ## [1] 625 This is the equivalent of (52)2. "],
["thats-all-for-now.html", "Chapter 7 That’s All! (for now)", " Chapter 7 That’s All! (for now) So there are the basics of what you need to know to get started in R! I hope you found this useful. I know there is a lot of information here but once you get the hang of it, this stuff will seem trivial. When I first learned this introductory material, I thought I would never be able to remember all the rules and syntax but the more you implement these skills, the less you need to look at reference material like this workbook and help files and the more you see how truly versatile this amazing program is. Keep in mind that there are tons of resources out there to help you learn R (see the website). I can’t tell you how many times typing out a word-for-word question into Google helped me get past a dead end. Now go try out EXERCISE 2 (this one’s a bit trickier!). "]
]
