\documentclass[]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{fixltx2e} % provides \textsubscript
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
\else % if luatex or xelatex
  \ifxetex
    \usepackage{mathspec}
  \else
    \usepackage{fontspec}
  \fi
  \defaultfontfeatures{Ligatures=TeX,Scale=MatchLowercase}
\fi
% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available
\IfFileExists{microtype.sty}{%
\usepackage{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\usepackage[margin=1in]{geometry}
\usepackage{hyperref}
\hypersetup{unicode=true,
            pdftitle={Introduction to R for Natural Resource Scientists},
            pdfauthor={Ben Staton},
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls
\usepackage{natbib}
\bibliographystyle{apalike}
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\usepackage{longtable,booktabs}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
\IfFileExists{parskip.sty}{%
\usepackage{parskip}
}{% else
\setlength{\parindent}{0pt}
\setlength{\parskip}{6pt plus 2pt minus 1pt}
}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
% Redefines (sub)paragraphs to behave more like sections
\ifx\paragraph\undefined\else
\let\oldparagraph\paragraph
\renewcommand{\paragraph}[1]{\oldparagraph{#1}\mbox{}}
\fi
\ifx\subparagraph\undefined\else
\let\oldsubparagraph\subparagraph
\renewcommand{\subparagraph}[1]{\oldsubparagraph{#1}\mbox{}}
\fi

%%% Use protect on footnotes to avoid problems with footnotes in titles
\let\rmarkdownfootnote\footnote%
\def\footnote{\protect\rmarkdownfootnote}

%%% Change title format to be more compact
\usepackage{titling}

% Create subtitle command for use in maketitle
\newcommand{\subtitle}[1]{
  \posttitle{
    \begin{center}\large#1\end{center}
    }
}

\setlength{\droptitle}{-2em}

  \title{Introduction to R for Natural Resource Scientists}
    \pretitle{\vspace{\droptitle}\centering\huge}
  \posttitle{\par}
    \author{Ben Staton}
    \preauthor{\centering\large\emph}
  \postauthor{\par}
      \predate{\centering\large\emph}
  \postdate{\par}
    \date{with contributions from Henry Hershey}

\usepackage{booktabs}
\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\usepackage{amsthm}
\newtheorem{theorem}{Theorem}[chapter]
\newtheorem{lemma}{Lemma}[chapter]
\theoremstyle{definition}
\newtheorem{definition}{Definition}[chapter]
\newtheorem{corollary}{Corollary}[chapter]
\newtheorem{proposition}{Proposition}[chapter]
\theoremstyle{definition}
\newtheorem{example}{Example}[chapter]
\theoremstyle{definition}
\newtheorem{exercise}{Exercise}[chapter]
\theoremstyle{remark}
\newtheorem*{remark}{Remark}
\newtheorem*{solution}{Solution}
\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\chapter*{Overview}\label{overview}
\addcontentsline{toc}{chapter}{Overview}

This is intended to be a first course in R programming. It is by no
means comprehensive, but instead attempts to introduce the main topics
needed to get a beginner up and running with applying R to their own
work. There will be no prior knowledge assumed on the part of the
student regarding R or programming. In the later chapters, e.g.,
Chapters \ref{ch3} and \ref{ch4}, an understanding of statistics at the
introductory undergraduate level would be helpful.

\chapter{Introduction to the R Environment}\label{ch1}

\subsection{\texorpdfstring{\textbf{Instructor:} Ben
Staton}{Instructor: Ben Staton}}\label{instructor-ben-staton}

\begin{center}\rule{0.5\linewidth}{\linethickness}\end{center}

\section*{Session Overview}\label{session-overview}
\addcontentsline{toc}{section}{Session Overview}

In this first session, we will get familiar with the basics of using R.
We will cover:

\begin{itemize}
\tightlist
\item
  the use of R as a basic calculator
\item
  object types
\item
  data classes
\item
  data structures
\item
  how to read in data
\item
  how to write out data
\item
  how to write your own functions
\end{itemize}

\section{Getting Started: Install R and
RStudio}\label{getting-started-install-r-and-rstudio}

First off, you will need to get R and RStudio\footnote{While it is
  possible to run R on it's own, it rather clunky and you are strongly
  advised to use RStudio given its compactness, neat features, code
  tools (like syntax and parentheses highlighting). This workshop will
  assume you are using RStudio} onto your computer. Please see
\textbf{Appendix A} for details on installing these programs on your
operating system.

\section{The R Studio Interface}\label{the-r-studio-interface}

Once you open up R Studio for the first time, you will see three panes:
the left hand side is the \textbf{console} where results from executed
commands are printed, and the two panes on the right are for additional
information to help you code more efficiently - don't worry too much
about what these are at the moment. For now, focus your attention on the
console.

\subsection{Write Some Simple Code}\label{write-some-simple-code}

To start off, we will just use R as a calculator. Type these commands
one at a time and hit \textbf{CTRL + Enter} to run it. The spaces don't
matter at all, they are used here for clairity and for styling.

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \OperatorTok{+}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] -1
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{3} \OperatorTok{*}\StringTok{ }\DecValTok{12}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 36
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{8} \OperatorTok{/}\StringTok{ }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 4
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2} \OperatorTok{^}\StringTok{ }\DecValTok{3}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

Notice that when you run each line, it prints the command and the output
to the console. The format I'm using prints the output with
\texttt{\#\#} in front of each line, but that will not happen on your
computer screen.

R is an \textbf{object oriented language}, which means that you fill
objects with data do things with them. Let's make some objects and call
them \texttt{a}, \texttt{b}, and \texttt{c}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{a =}\StringTok{ }\DecValTok{3} \OperatorTok{+}\StringTok{ }\DecValTok{3}
\NormalTok{a}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 6
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{b <-}\StringTok{ }\DecValTok{5} \OperatorTok{+}\StringTok{ }\DecValTok{2}
\NormalTok{b}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 7
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{c =}\StringTok{ }\NormalTok{a }\OperatorTok{+}\StringTok{ }\NormalTok{b}
\end{Highlighting}
\end{Shaded}

Notice that running the first line did not return a value to the
console. This is because in that line you are \textbf{assigning} a
value. You can view your object by typing its name alone and running it
(or by double clicking the name where you assigned it to highlight it,
which is much faster). The \texttt{=} sign or \texttt{\textless{}-} can
both be used to assign values to objects. This is a matter of personal
preference: I often see hardcore programmers use the
\texttt{\textless{}-}, but I prefer the \texttt{=} because it is only
one key as opposed to three. You can run multiple lines at a time by
highlighting them before running. You may also run portions of a line at
a time by highlighting only the desired portion. You can run a single
entire line by simply placing your cursor on that line and hitting CTRL
+ R. CTRL + ENTER will run code as well (unless you are on a Mac, in
which case I think you switch out the CTRL for CMD).

\chapter{Saving Scripts and the Working
Directory}\label{saving-scripts-and-the-working-directory}

You will want to save your hard work. But first, let's talk about the
\textbf{working directory}. The working directory is a folder on your
computer that R looks for files by default. Working directories become
very useful when bringing in datasets and saving output so you should
get used to using them now. To choose the working directory, go to
Session \textgreater{} Set Working Directory \textgreater{} Choose
Directory. I recommend having distinct working directories for different
tasks. For example, for a class with several lab assignments, I would
have a folder for each assignment that serves as the working directory
for that assignment and stores my script(s) and data set(s). Once your
working directory is set, go to File \textgreater{} Save. The working
directory opens up automatically now and you can call your script
whatever you would like. It will be saved as an .R file, which is
essentially a text file.

\chapter{R Object and Data Types}\label{r-object-and-data-types}

R has a variety of object types that you will need to become familiar
with. The primary types for storing data are \textbf{vectors},
\textbf{matrices}, and \textbf{data frames}. There are others (e.g.,
lists, arrays, tables, etc.) but we will not go into those just yet for
simplicity's sake. \textbf{Vectors} are a list of values (numeric or
character), in only one dimension, and are thus the simplest of the
object types. Above, we made \texttt{a}, which was a numeric vector with
one element. \textbf{Matrices} are values in two dimensions, and can be
thought of as rows or columns of combined vectors. Vectors and matrices
hold values of all the same type, for example, a vector can be a
character vector where all the elements are words or letters or it can
be numeric, where they are all numbers. The same goes for matrices.
\textbf{Data frames}, by contrast, can have multiple data types between
different columns. Every row and column of matrices and data frames must
have the same number of elements (length). We will use all three of
these object types extensively in this workshop.

\textbf{Functions} are built-in objects in R that perform specific
tasks. For example, there is a \texttt{mean} function that calculates
the mean of a vector of numbers. There are tons of functions in R that
range in their complexity. We will start with basic functions (like
\texttt{mean}, \texttt{sd}, \texttt{length}, etc.) and build up from
there. One part about R that makes it really versatile and cool is that
you can write your own functions to carry out your own specific tasks.
We will cover this topic in more detail later.

It is very important to know what kind of object type you are using,
since R treats them differently. For example, some functions can only
use a certain object type. The same holds true for data types (numeric
vs.~character vs.~factor). You will get some very interesting results if
you attempt to take the mean of a factor (i.e., a categorical number or
character). Note that you can quickly determine what kind of object you
are dealing with by using the \texttt{class} function. Simply run
\texttt{class(object.name)}.

\chapter{Making Some Data}\label{making-some-data}

We will begin by making some vectors. The way you do this is by using
the \texttt{c()} function. The ``c'' stands for ``concatenate'' or
combine some values into one object.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{15}\NormalTok{)}
\NormalTok{ponds =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"F11"}\NormalTok{, }\StringTok{"S28"}\NormalTok{, }\StringTok{"S30"}\NormalTok{, }\StringTok{"S8"}\NormalTok{, }\StringTok{'S11'}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

There are shortcuts to make patterns of numbers:

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{2010}\OperatorTok{:}\DecValTok{2014}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2010 2011 2012 2013 2014
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{2001}\NormalTok{, }\DataTypeTok{to =} \DecValTok{2005}\NormalTok{, }\DataTypeTok{by =} \DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2001 2002 2003 2004 2005
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{2001}\NormalTok{, }\DecValTok{2005}\NormalTok{, }\DecValTok{1}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2001 2002 2003 2004 2005
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{rep}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{5}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 10 10 10 10 10
\end{verbatim}

Notice that lines 2 and 3 above do the exact same thing. Line 2 uses
named arguments. An \textbf{argument} is a command you give to a
function to tell it what to do. All functions have arguments, and they
all have names. By specifying the names within the function, you don't
have to remember what order the arguments go in (i.e.,
\texttt{seq(to=5,\ from=1,\ by=1)} is the same as
\texttt{seq(1,\ 5,\ 1)} and they are both different from
\texttt{seq(1,1,5)}).

R has lots of information to help you learn how to use a function. Let's
look at the help file for the mean function. Type \texttt{help(mean)}.
The help file tells you what goes into a function and what comes out.
For more complex functions it also tells you what all of the options
(i.e., arguments) can do. Now let us use the mean function.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(num)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8.8
\end{verbatim}

A quick aside. One of the really nice things about R is that it can do
vectorized calculations. This means that if you tell it to, it will do
something to every element in the vector. For example, if we wanted to
add one number to every element of the vector \texttt{num} and call the
result \texttt{num2}, then we would just type:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num2 =}\StringTok{ }\NormalTok{num}\OperatorTok{+}\DecValTok{1}
\NormalTok{num2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5  8  9 11 16
\end{verbatim}

Similarly, if we add two vectors, it will take the first element of the
first vector and add it to the first element of the second vector and so
on and so forth. This works for adding, subtracting, multiplying,
dividing, taking exponents, etc. Note that the two vectors must have the
same length.

Okay, now let us make some matrices. The way I like to make matrices by
hand is by combining several vectors (again of the same length). There
are two functions that allow us to do this: \texttt{rbind} (by row) and
\texttt{cbind} (by column).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1 =}\StringTok{ }\KeywordTok{cbind}\NormalTok{(num, num2, }\DecValTok{2010}\OperatorTok{:}\DecValTok{2014}\NormalTok{)}
\NormalTok{m1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      num num2     
## [1,]   4    5 2010
## [2,]   7    8 2011
## [3,]   8    9 2012
## [4,]  10   11 2013
## [5,]  15   16 2014
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2 =}\StringTok{ }\KeywordTok{rbind}\NormalTok{(num, num2, }\DecValTok{2010}\OperatorTok{:}\DecValTok{2014}\NormalTok{)}
\NormalTok{m2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## num     4    7    8   10   15
## num2    5    8    9   11   16
##      2010 2011 2012 2013 2014
\end{verbatim}

Note that when we used named objects (\texttt{num}, \texttt{num2}) it
kept the names. You can return these names by using \texttt{colnames} to
get column names and \texttt{rownames} to get row names. If it returns
\texttt{NULL}, then there are no row or column names.

Now let's look at a point I mentioned earlier. Remember how all of the
elements in a matrix (and vectors) must be of the same type (e.g.,
character vs.~numeric)? Let's try to combine a character vector and a
numeric vector into a matrix:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{cbind}\NormalTok{(ponds, num)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      ponds num 
## [1,] "F11" "4" 
## [2,] "S28" "7" 
## [3,] "S30" "8" 
## [4,] "S8"  "10"
## [5,] "S11" "15"
\end{verbatim}

The quotes mean that R is now treating them all as characters. It
\textbf{coerced} (or turned) the numbers into characters. Is this what
we wanted? Probably not because once things are characters, you can no
longer do math on them. To combine vectors of data that have different
types we will need to use a data frame.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1 =}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(ponds, }\DataTypeTok{years =} \DecValTok{2010}\OperatorTok{:}\DecValTok{2014}\NormalTok{, num)}
\NormalTok{df1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   ponds years num
## 1   F11  2010   4
## 2   S28  2011   7
## 3   S30  2012   8
## 4    S8  2013  10
## 5   S11  2014  15
\end{verbatim}

Data frames are what we usually use when analyzing data because of this
property.

\chapter{Retrieving data from
objects}\label{retrieving-data-from-objects}

This is one of the most important and versatile skills to know in R. So
we have an object with data in it and we want to use it for analysis.
But we don't want the whole dataset, we just want one column. How do we
pull out that one column? Another term for pulling out only data we want
is \emph{query}. Well it turns out there are two main ways to query
data.

\textbf{1. Indexing}. This method allows you to pull out specific
columns/rows by their location in an object. However, you must know
exactly where in the object the desired data are. To index, you specify
the object, then what rows, then what columns. The syntax is:
\texttt{object{[}row,\ column{]}}. For example, let's pull out the first
row of the data frame \texttt{df1} using indexing:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1[}\DecValTok{1}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   ponds years num
## 1   F11  2010   4
\end{verbatim}

This works on matrices as well. Here are some examples:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1[}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{]          }\CommentTok{# pulls out the element in the first row, second column from m1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## num2 
##    5
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1[, }\DecValTok{2}\NormalTok{]           }\CommentTok{# pulls out the whole second column (every row) from m1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  5  8  9 11 16
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m2[, }\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{]         }\CommentTok{# pulls out columns 2, 3, and 4 from m2}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      [,1] [,2] [,3]
## num     7    8   10
## num2    8    9   11
##      2011 2012 2013
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{m1[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{), ]  }\CommentTok{# pulls out the 1st, 2nd, and 4th, rows, with every column from m1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##      num num2     
## [1,]   4    5 2010
## [2,]   7    8 2011
## [3,]  10   11 2013
\end{verbatim}

Vectors are done the same way, except you only provide one number
because there is only one dimension. For example: \texttt{num{[}3{]}}
pulls out the 3\textsuperscript{rd} element of the vector \texttt{num}.

\textbf{2. By name} -- This method allows you to pull out a specific
column of data based on what the column name is. Of course, the column
must have a name first. The name method uses the \texttt{\$} operator:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1}\OperatorTok{$}\NormalTok{num}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1]  4  7  8 10 15
\end{verbatim}

You can combine these two methods:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1}\OperatorTok{$}\NormalTok{num[}\DecValTok{3}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 8
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# or}
\NormalTok{df1[, }\StringTok{"years"}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 2010 2011 2012 2013 2014
\end{verbatim}

The by name (\texttt{\$}) method is useful because it can be used to add
columns to a data frame:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{df1}\OperatorTok{$}\NormalTok{num3 =}\StringTok{ }\KeywordTok{seq}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\NormalTok{df1}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##   ponds years num num3
## 1   F11  2010   4    1
## 2   S28  2011   7    3
## 3   S30  2012   8    5
## 4    S8  2013  10    7
## 5   S11  2014  15    9
\end{verbatim}

Both are very useful, and we will be making frequent use of these
methods for the rest of the workshop. The \texttt{\$} operator only
works on data frames, not matrices. I'll mention briefly that there is
another way to query data: logically. We will cover this in the next
section. Now go and try your hand at applying these skills in
\textbf{EXERCISE 1}.

\chapter{Bringing in Your Data}\label{bringing-in-your-data}

It is rare that we will enter our data by hand as we did in Exercise 1.
Often, we have a dataset that we wish to analyze or manipulate. R has
several ways to bring in data and in this workshop, we will be using the
most common and flexible approach: reading in .csv files. CSV files are
data files that separate columns with commas. If your data are in an
Excel spreadsheet, save your Excel file as a CSV file (File
\textgreater{} Save As \textgreater{} Save as Type\textgreater{} CSV
(Comma Delimited)). Excel will give lots of dialog boxes asking if you
are sure you want to save it as a CSV (you do) and if you wish to save
it. A few things to note:

\begin{itemize}
\item
  No cells can contain the ``\#VALUE!'' or ``NUM'' result that often
  happens when the result of an Excel function is invalid. If one of
  these is found in a column, R will treat that \emph{entire} column as
  a factor (because it contains characters), which causes problems when
  you do not want that column to be a factor (remember a factor is a
  grouping variable, like treatment, location, or species).
\item
  If a cell in the first row with text contains a space between two
  words, R will insert a \texttt{"."} between the words.
\item
  R can deal with missing values by turning them into \texttt{NA}.
  However, everywhere you want R to have an \texttt{NA}, those cells
  must contain the same information in the CSV file. These can be
  completely empty cells, or you could put a \texttt{"."} into every
  cell that you want R to treat as an \texttt{NA}. If you use
  ``\texttt{.}'' to signify \texttt{NA} in your CSV file, include
  \texttt{na.strings\ =\ "."} as an argument to the \texttt{read.csv()}
  function described below. Of course, you can also simply type ``NA''
  in the CSV file wherever NA's occur.
\item
  If your data have column names (i.e., characters) in the first row, R
  will bring those in as column names by default.
\item
  R brings in CSV files in as data frames by default.
\end{itemize}

The website I'm using won't let me upload CSV files, so we will have to
convert Excel workbooks (.xlsx) to CSV files. Once that is done, to
bring (read) in a CSV file we use the function \texttt{read.csv()}.
\texttt{read.csv()} has several arguments (look at the help file for
details), but only one is really necessary: the file name (or location).
Let's convert and read in the provided dataset ``streams.xlsx'' (there
are no problems with this dataset, so don't worry):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat =}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"streams.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If the data set is in your working directory, all you need to provide is
the file name (remember case, quotes, and .csv at the end!). If the file
is \emph{not} in your working directory, you must type (or copy/paste)
the \emph{full} file path. Note that R requires the use of \texttt{/}
and not \texttt{\textbackslash{}} in file paths. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat =}\StringTok{ }\KeywordTok{read.csv}\NormalTok{(}\StringTok{"C:/Users/Ben/Desktop/Auburn R Workshops/Session 1/Session 1 MarkDown/Session-1-data.csv"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

If you did not get any errors, then the data are in the object you named
and that object is a data frame. If you get errors (e.g.,
\texttt{...No\ such\ file\ or\ directory}) then make sure you have
spelled everything correctly, used the right case and symbols, and have
included a ``.csv'' at the end of the file name. Don't worry, this is
probably one of the most common errors I get in R.

There is a neat trick to simplify this. Running
\texttt{read.csv(file.choose())} pulls up a window that allows you to
interactively choose the file you want. (running \texttt{file.choose}
returns the file path of the file you select, so it is really just the
same as typing in the file path, but easier). I don't use this for
complex analyses, because when I come back to that script later, I want
to make sure I'm using the right data file. Typing the file name instead
of using \texttt{file.choose}helps me with this.

Let's look at the data. We could just run the object, but it will show
the whole thing, which may be undesirable if the dataset is large. To
view the first six rows, run \texttt{head(dat)} or the last six rows
with \texttt{tail(dat)}.

Okay, now we will use some basic functions to explore our data before
any analysis. The \texttt{summary} function is very useful, and it can
be used on a large variety of different objects.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(dat)}
\end{Highlighting}
\end{Shaded}

We can now see the spread of our numeric data and see the different
levels of our factor (\texttt{state}) as well as how many data points
belong to each category. Note that we have one \texttt{NA} in our
\texttt{flow} variable.

To count the number of elements in a variable (or any vector), we use
the \texttt{length} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(dat}\OperatorTok{$}\NormalTok{stream_width)}
\end{Highlighting}
\end{Shaded}

Note that R counts missing values as elements as well:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(dat}\OperatorTok{$}\NormalTok{flow)}
\end{Highlighting}
\end{Shaded}

To get the dimensions of an object with more than one dimension (i.e., a
data frame, matrix, or array) we can use the \texttt{dim} function. This
returns a vector of length 2: the first number is the number of rows and
the second is the number of columns. If you only want one of these, use
the \texttt{nrow} or \texttt{ncol} functions (but remember, only for
objects with more than one dimension; vectors don't have rows or
columns!).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dim}\NormalTok{(dat)}
\end{Highlighting}
\end{Shaded}

Let's calculate the mean of all of our flow data:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(dat}\OperatorTok{$}\NormalTok{flow)}
\end{Highlighting}
\end{Shaded}

It returned an \texttt{NA} because there is an \texttt{NA} in this
variable. There is a way to tell R to ignore this \texttt{NA}. Include
the argument \texttt{na.rm\ =\ TRUE} in the \texttt{mean} function
(separate arguments are always separated by commas). This is a
\textbf{logical} argument, meaning that it asks a question. Do you want
to remove \texttt{NAs} before calculating the mean? \texttt{TRUE} means
yes and \texttt{FALSE} means no. These can be abbreviated as \texttt{T}
or \texttt{F}. Lots of R's functions have the \texttt{na.rm} argument
(e.g. \texttt{mean}, \texttt{sd}, \texttt{var}, \texttt{min},
\texttt{max}, \texttt{sum}, etc.).

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{mean}\NormalTok{(dat}\OperatorTok{$}\NormalTok{flow, }\DataTypeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

What if we want to do something to more than one variable at a time? The
best way to do this (as with lots of things in R, there are many) is by
using the \texttt{apply} function. This applies the same function to a
subset of data. Note that we must specify the \texttt{na.rm} argument to
the \texttt{var} function within the \texttt{apply} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{apply}\NormalTok{(dat[,}\DecValTok{2}\OperatorTok{:}\DecValTok{3}\NormalTok{], }\DecValTok{2}\NormalTok{, }\DataTypeTok{FUN =}\NormalTok{ var, }\DataTypeTok{na.rm =}\NormalTok{ T)}
\end{Highlighting}
\end{Shaded}

The first argument is the data we want to apply the function to. The
second argument (the number \texttt{2}) specifies that we want to apply
the function to columns, \texttt{1} would tell R to apply it to rows.
The \texttt{FUN} argument specifies what function we wish to apply; here
we are calculating the variance. There is a whole family of
\texttt{apply} functions, the base \texttt{apply} is the most basic but
a more sophisticated one is \texttt{tapply}, which applies a function
based on some grouping variable. Let's calculate the mean stream width
for every state:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{tapply}\NormalTok{(dat}\OperatorTok{$}\NormalTok{stream_width, dat}\OperatorTok{$}\NormalTok{state, mean)}
\end{Highlighting}
\end{Shaded}

The first argument is the data you want to apply the \texttt{mean}
function to, the second is the grouping variable, and the third is what
function you wish to apply.

\chapter{\texorpdfstring{Logic, \texttt{if}, \texttt{else}, and
\texttt{ifelse}}{Logic, if, else, and ifelse}}\label{logic-if-else-and-ifelse}

R is a very logical language, both in a literal a figurative sense. When
we say ``logical'', as alluded to before, we are really talking about a
question. You will also see these referred to as \textbf{conditionals}.
Which values in a vector meet some condition (greater than some number,
are equal to some number, have the same characters, etc.)? Let's start
with some very basic R logic (note that reassigning a value to
\texttt{num} will write over what it was before, be careful with this):

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num =}\StringTok{ }\DecValTok{5}   \CommentTok{# assign a value to the object num}
\NormalTok{num }\OperatorTok{<}\StringTok{ }\DecValTok{5}   \CommentTok{# ask if it is less than 5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] FALSE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num }\OperatorTok{<=}\StringTok{ }\DecValTok{5}  \CommentTok{# ask if it is less than or equal to 5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{num }\OperatorTok{==}\StringTok{ }\DecValTok{5}  \CommentTok{# ask if it is exactly equal to 5}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] TRUE
\end{verbatim}

Each of these lines (after the first which assigns a value to value)
asks a question: does \texttt{num} meet the specified condition? It
returns \texttt{TRUE} if it does, and \texttt{FALSE} if it doesn't. Note
that the logical equals is specified by using \texttt{==}.

We can tell R to do something if the result of our logical question is
\texttt{TRUE}. This is a typical if-then statement.

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (num }\OperatorTok{==}\StringTok{ }\DecValTok{5}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"num is equal to 5"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "num is equal to 5"
\end{verbatim}

This says ``if \texttt{num} equals 5, then print the phrase `num is
equal to 5' to the console''. If the logical returns a \texttt{FALSE},
then this command does nothing:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (num }\OperatorTok{!=}\StringTok{ }\DecValTok{5}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"num is equal to 5"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The \texttt{!} is the logical \emph{not}. It asks the question ``is
\texttt{num} not equal to 5?''. We can tell R to do multiple things if
the logical is \texttt{TRUE} by using curly braces:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (num }\OperatorTok{==}\StringTok{ }\DecValTok{5}\NormalTok{) \{}
  \KeywordTok{print}\NormalTok{(}\StringTok{"num is equal to 5"}\NormalTok{)}
  \KeywordTok{print}\NormalTok{(}\StringTok{"num is supposed to be 6"}\NormalTok{)}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "num is equal to 5"
## [1] "num is supposed to be 6"
\end{verbatim}

But what if we want R to do something if the logical is \texttt{FALSE}?
Then we use the \texttt{else} command:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (num }\OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{) }\KeywordTok{print}\NormalTok{(}\StringTok{"num is greater than 5"}\NormalTok{) }\ControlFlowTok{else} \KeywordTok{print}\NormalTok{(}\StringTok{"num is not greater than 5"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "num is not greater than 5"
\end{verbatim}

Or on two lines:

\begin{Shaded}
\begin{Highlighting}[]
\ControlFlowTok{if}\NormalTok{ (num }\OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{) \{}
  \KeywordTok{print}\NormalTok{(}\StringTok{"num is greater than 5"}\NormalTok{)}
\NormalTok{\} }\ControlFlowTok{else} \KeywordTok{print}\NormalTok{(}\StringTok{"num is not greater than 5"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] "num is not greater than 5"
\end{verbatim}

The \texttt{if} function is very useful, but it can only ask one
question at a time. If you supply it with a vector of length greater
than 1, it will give a warning that only the first value is used.
(Warnings are different than errors in that something still happens, but
it tells you that it might not be what you wanted, whereas an error
stops R altogether.) To ask multiple questions at once, we must use
\texttt{ifelse}. This function is similar, but it combines the syntax
into one function:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nums =}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OperatorTok{-}\DecValTok{5}\OperatorTok{:-}\DecValTok{1}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{)}
\KeywordTok{ifelse}\NormalTok{(nums }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{, }\StringTok{"positive"}\NormalTok{, }\StringTok{"negative"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
##  [1] "negative" "negative" "negative" "negative" "negative" "positive"
##  [7] "positive" "positive" "positive" "positive"
\end{verbatim}

The syntax is
\texttt{ifelse(logical\ condition,\ do\ if\ TRUE,\ do\ if\ FALSE)}.
Let's use \texttt{ifelse} to create a new variable in \texttt{dat} that
tells us if each stream is big or small depending on some cut-off we
choose:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat}\OperatorTok{$}\NormalTok{size =}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(dat}\OperatorTok{$}\NormalTok{stream_width }\OperatorTok{>}\StringTok{ }\DecValTok{50}\NormalTok{, }\StringTok{"big"}\NormalTok{, }\StringTok{"small"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

This says ``make a new variable in the data frame \texttt{dat} called
\texttt{size} and assign each row a `big' if \texttt{stream\_width} is
greater than 50 or `small' if less than 50''.

One neat thing about \texttt{ifelse} is that you can nest multiple
statements inside another (this is true of ALL R functions, by the way).
What if we wanted three categories: small, medium, and large?

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat}\OperatorTok{$}\NormalTok{size_fine =}\StringTok{ }\KeywordTok{ifelse}\NormalTok{(dat}\OperatorTok{$}\NormalTok{stream_width }\OperatorTok{<=}\StringTok{ }\DecValTok{40}\NormalTok{, }\StringTok{"small"}\NormalTok{,}
                     \KeywordTok{ifelse}\NormalTok{(dat}\OperatorTok{$}\NormalTok{stream_width }\OperatorTok{>}\StringTok{ }\DecValTok{40} \OperatorTok{&}\StringTok{ }\NormalTok{dat}\OperatorTok{$}\NormalTok{stream_width }\OperatorTok{<=}\StringTok{ }\DecValTok{70}\NormalTok{, }\StringTok{"medium"}\NormalTok{, }\StringTok{"big"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

If the value is \texttt{TRUE}, then it will give it a ``small''. If not,
it will start another \texttt{ifelse} to ask if the value is greater
than 50 \emph{and} less than or equal to 70. If so, it will give it a
``medium'', if not it will get a ``big''. This is confusing at first, I
know. Not all nesting or embedding of functions are this complex, but
this is a neat example. Without \texttt{ifelse}, you would have to use
as many \texttt{if} statements as there are data points, and do you
really want to do that? I'll note that in addition to the logical
\emph{and} (\texttt{\&}) there is a logical \emph{or}, denoted by the
bar symbol (\texttt{\textbar{}}).

\chapter{Logical Subsetting}\label{logical-subsetting}

This is my favorite way of subsetting (or querying or retrieving data,
however you want to say it) an object. It pulls out all of the elements
of an object for which the test is \texttt{TRUE}. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat}\OperatorTok{$}\NormalTok{flow[dat}\OperatorTok{$}\NormalTok{stream_width }\OperatorTok{>}\StringTok{ }\DecValTok{60}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Gives all of the flow values for which stream width is greater than 60.
Or to see all of the data from Alabama:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat[dat}\OperatorTok{$}\NormalTok{state }\OperatorTok{==}\StringTok{ "Alabama"}\NormalTok{,]}
\end{Highlighting}
\end{Shaded}

The \texttt{subset()} function does this same thing:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{subset}\NormalTok{(dat, state }\OperatorTok{==}\StringTok{ "Alabama"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

The syntax is \texttt{subset(object,\ condition)}. You can specify
multiple conditions:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{big.TN.FL.rivers =}\StringTok{ }\KeywordTok{subset}\NormalTok{(dat, dat}\OperatorTok{$}\NormalTok{size_fine }\OperatorTok{==}\StringTok{ "big"} \OperatorTok{&}\StringTok{ }
\StringTok{              }\NormalTok{(dat}\OperatorTok{$}\NormalTok{state }\OperatorTok{==}\StringTok{ "Tennessee"} \OperatorTok{|}\StringTok{ }\NormalTok{dat}\OperatorTok{$}\NormalTok{state }\OperatorTok{==}\StringTok{ "Florida"}\NormalTok{))}
\NormalTok{big.TN.FL.rivers}
\end{Highlighting}
\end{Shaded}

This gives all rivers that are big and are in Tennessee or Florida. Note
that to do big and either in Tennessee or Florida, the states need to be
in parentheses because this last part is its own question.

\chapter{Writing Output Files}\label{writing-output-files}

Okay so now that we have made some new variables in our data frame, we
want to save this work in the form of a new CSV file. To do this, we can
use the \texttt{write.csv} function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{write.csv}\NormalTok{(dat, }\StringTok{"updated_output.csv"}\NormalTok{, }\DataTypeTok{row.names =}\NormalTok{ F)}
\end{Highlighting}
\end{Shaded}

The first argument is the data frame (or matrix) to write, the second is
what you want to call it, and \texttt{row.names\ =\ F} tells R to not
include the row names (because here they are just numbers in this case).
R puts the file in your working directory by default. To put it
somewhere else, type in the path with the new file name at the end.

\chapter{Basic User-Defined
Functions}\label{basic-user-defined-functions}

Sometimes we want R to carry out a specific task, but there is no
function built in to do it. In this case, we can write our own
functions. This is one of the coolest parts of R, and I will only
introduce it here. We will be going into more detail on this topic in
later sessions.

First, we must think of a name for our function. Then, we specify the
function using the \texttt{function} function. Then, in parentheses, we
specify any arguments that we want to use within the function to carry
out the specific task. Open and closed curly braces specify the start
and end of our function. Let's write a general function to take any
number to any power:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{power =}\StringTok{ }\ControlFlowTok{function}\NormalTok{(x, y)\{}
\NormalTok{  x}\OperatorTok{^}\NormalTok{y}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Now let's test our function:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{power}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 125
\end{verbatim}

Remember, we can embed functions:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{power}\NormalTok{(}\KeywordTok{power}\NormalTok{(}\DecValTok{5}\NormalTok{,}\DecValTok{2}\NormalTok{),}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{verbatim}
## [1] 625
\end{verbatim}

This is the equivalent of (5\textsuperscript{2})\textsuperscript{2}.

\chapter{That's All! (for now)}\label{thats-all-for-now}

So there are the basics of what you need to know to get started in R! I
hope you found this useful. I know there is a lot of information here
but once you get the hang of it, this stuff will seem trivial. When I
first learned this introductory material, I thought I would never be
able to remember all the rules and syntax but the more you implement
these skills, the less you need to look at reference material like this
workbook and help files and the more you see how truly versatile this
amazing program is. Keep in mind that there are \emph{tons} of resources
out there to help you learn R (see the website). I can't tell you how
many times typing out a word-for-word question into Google helped me get
past a dead end.

Now go try out \textbf{EXERCISE 2} (this one's a bit trickier!).

\chapter{Base R Plotting Basics}\label{ch2}

\chapter{Basic Statistics}\label{ch3}

\chapter{Simulation and Randomization}\label{ch4}

\chapter{Large Data Manipulation}\label{ch5}

\bibliography{book.bib,packages.bib}


\end{document}
